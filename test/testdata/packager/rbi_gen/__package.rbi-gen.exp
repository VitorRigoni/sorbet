# test/testdata/packager/rbi_gen/RBIGen_Package.rbi
# typed: true

module RBIGen::Public
end
module RBIGen::Public::VariousMethods
  sig {params(a: RBIGen::Private::PrivateClassPulledInByPrivateMethod).void}
  private def my_method(a); end
  sig {void}
  private def sample_mod_fcn; end
  extend T::Sig
  sig {void}
  private_class_method def self.kls_method; end
  sig {void}
  def self.sample_mod_fcn; end
end
class RBIGen::Private::PrivateClassPulledInByPrivateMethod < Object
end
class RBIGen::Public::SealedClass < Object
  sealed!
  extend T::Helpers
end
class RBIGen::Public::RefersToPrivateTypes < Object
  sig {params(a: RBIGen::Private::PrivateClass).void}
  def method(a); end
  extend T::Sig
end
class RBIGen::Private::PrivateClass < Object
end
RBIGen::Public::RefersToPrivateTypes::ClassAlias = RBIGen::Private::PrivateClassPulledInByClassAlias
class RBIGen::Private::PrivateClassPulledInByClassAlias < Object
end
class RBIGen::Public::MyStruct < T::Struct
  prop :foo, Integer
  const :bar, T.nilable(String), default: T.let(T.unsafe(nil), T.nilable(String))
  const :quz, Float, default: T.let(T.unsafe(nil), Float)
  sig {returns(Integer)}
  def extra_method; end
  extend T::Sig
  @field = T.let(T.unsafe(nil), Integer)
end
class RBIGen::Public::MyEnum < T::Enum
  abstract!
  sealed!
  sig {returns(String)}
  def to_string; end
  extend T::Sig
  extend T::Helpers
  enums do
    Clubs = new
    Diamonds = new
    Hearts = new
    Spades = new
  end
end
module RBIGen::Public::ModuleWithTypeParams
  A = type_member(:in)
  B = type_member(:out)
  extend T::Generic
  extend T::Helpers
end
RBIGen::Public::MaybeString = T.type_alias {T.nilable(String)}
module RBIGen::Public::InterfaceModule
  abstract!
  interface!
  sig {abstract.returns(String)}
  def interface_method; end
  extend T::Sig
  extend T::Helpers
end
class RBIGen::Public::FinalClass < Object
  final!
  sig(:final) {void}
  def final_method; end
  extend T::Sig
  extend T::Helpers
end
class RBIGen::Public::FieldCheck < Object
  @@static_field = T.let(T.unsafe(nil), Integer)
  sig {void}
  def initialize
    @field = T.let(T.unsafe(nil), Integer)
  end
  extend T::Sig
  @statically_declared_field = T.let(T.unsafe(nil), Integer)
end
RBIGen::Public::FieldCheck::Constant = T.let(T.unsafe(nil), Integer)
RBIGen::Public::FieldCheck::AliasConstant = T.let(T.unsafe(nil), T.class_of(RBIGen::Public::FieldCheck))
RBIGen::Public::FieldCheck::Alias = RBIGen::Public::FieldCheck
module RBIGen::Public::DefDelegator
  def_delegator :@field, :concat, :aliased_concat
  def_delegator :@field, :empty
  def_delegator :@field, :length
  def_delegator :@field, :size
  sig {void}
  def initialize
    @field = T.let(T.unsafe(nil), String)
  end
  extend Forwardable
  extend T::Helpers
  extend T::Sig
end
class RBIGen::Public::ClassWithTypeParams < Object
  C = type_member()
  extend T::Generic
  extend T::Helpers
  A = type_template(fixed: RBIGen::Private::PrivateClassPulledInByTypeTemplate)
  B = type_template()
end
class RBIGen::Private::PrivateClassPulledInByTypeTemplate < Object
end
class RBIGen::Public::AliasMethod < Object
  sig {params(other: BasicObject).returns(T::Boolean)}
  def ==(other); end
  sig {params(other: BasicObject).returns(T::Boolean)}
  def eql?(other); end
  extend T::Sig
end
class RBIGen::Public::AbstractClass < Object
  abstract!
  sig {abstract.returns(String)}
  def abstract_method; end
  extend T::Sig
  extend T::Helpers
end
class RBIGen::Public::AbstractAndInterfaceImplementor < RBIGen::Public::AbstractClass
  include RBIGen::Public::InterfaceModule
  sig {override.returns(String)}
  def abstract_method; end
  sig {override.returns(String)}
  def interface_method; end
end

# test/testdata/packager/rbi_gen/RBIGen_Package.test.rbi
# typed: true

class RBIGen::Private::PrivateClassForTests < Object
end
module Test::RBIGen
end
class Test::RBIGen::MyTestHelper < Object
end
class Test::RBIGen::MyTest < Object
end

